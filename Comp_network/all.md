 
**Computer Networks Lab (20CYS383)**
---
**A.ARJUN**                        
**CH.EN.U4CYS22006**
---

### Date:

### Tracert

The **tracert** command prints the path routers between the source and destination hosts' IP address.

![Tracert](./mediaBN/media/image1.png)

### Ping

The **ping** command is used to test connectivity between two hosts.

![Ping](./mediaBN/media/image2.png)

### Ipconfig

Displays all TCP/IP network configuration values and refreshes DHCP and DNS settings of the computer like IPv4 address, IPv6 address, subnet mask, and name of network.

![Ipconfig](./mediaBN/media/image3.png)

### Arp

The **arp** command for an IP address displays its MAC address in a table and its IP type.

![Arp](./mediaBN/media/image4.png)

### Netstat

The **netstat** command displays active connections, ports on which the computer is listening, Ethernet statistics, the IP routing table, and IP statistics.

![Netstat](./mediaBN/media/image5.png)

---
### Date:

### Wireshark

1. **Analyze the network traffic captured using Wireshark and identify the most commonly used network protocols.**

   ![](./mediaWS/media/image1.png)

   **1-IPv6**  
   **2-UDP**  
   **3-TCP**

2. **Investigate a specific network issue by analyzing captured packets in Wireshark and propose a solution.**

   ![](./mediaWS/media/image2.png)

   **TCP RST Flag:** The [RST] flag indicates that the sender is forcibly closing the connection. This might happen for several reasons:

   - The application on the sender's side encountered an error or is not expecting the connection.
   - The connection was idle for too long, and the sender is resetting it.
   - The sender received data it did not expect, possibly due to an out-of-order packet.

   Enable and properly configure TCP keep-alive on both ends of the connection to prevent unexpected resets due to idle time.

3. **Capture and analyze network packets to determine the source and destination IP addresses of a particular type of traffic (e.g., HTTP, DNS, FTP).**

   ![](./mediaWS/media/image3.png)

   Selected packets:  
   **Src: 64:ff9b::312c:74ee**  
   **Dst: 2409:40f4:38:4779:3903:251c:ba1e:1727**

4. **Use Wireshark to capture and analyze wireless network traffic, and identify any security vulnerabilities or potential attacks.**

   - EAPOL Packets: Filter for WPA/WPA2 authentication handshakes using `eapol`.
   - Deauthentication Frames: Look for deauthentication packets with `wlan.fc.type_subtype == 0x0c`.
   - ARP Packets: Filter for ARP traffic to detect potential ARP spoofing using `arp`.

   ![](./mediaWS/media/image4.png)  
   ![](./mediaWS/media/image5.png)  
   ![](./mediaWS/media/image6.png)
5. **You suspect that a certain computer in your network is sending sensitive data to an external server. How would you use Wireshark filters to monitor the traffic of that specific machine and identify any suspicious activities?**

   If we think ipv6 `64:ff9b::312c:74ee` is sending data, we can filter packets that have the source as that IP address using:

   **`ipv6.addr == 64:ff9b::312c:74ee && (http || ssl || ftp || dns)`**

   ![](./mediaWS/media/image7.png)

   `&& (http || ssl || ftp || dns)` is used to specify the type of packet.

6. **You need to analyze the HTTP traffic in your network to identify any potential security vulnerabilities. How would you use Wireshark filters to focus specifically on HTTP packets and extract relevant information for analysis?**

    Use the Wireshark filter `http` to focus specifically on HTTP packets. This filter will display all HTTP requests and responses, allowing you to examine the traffic.  
   ![](./mediaWS/media/image8.png)

   **GET requests** might expose sensitive data in URLs:

   - `http.request.method == "GET"`

   ![](./mediaWS/media/image9.png)

   **POST requests** may carry sensitive data in the payload:

   - `http.request.method == "POST"`

7. **Your company has recently implemented a new application, and you need to monitor the network traffic to assess its impact on network performance. How would you use Wireshark filters to analyze the traffic related to this specific application?**

   > Use Wireshark's filtering capabilities to focus specifically on the traffic generated by the new application. Depending on the application's characteristics, different filters can be applied:
   
   - **Filter by IP Address:**

     ![](./mediaWS/media/image10.png)

   - **Filter by Port Number:**  
     If the application uses specific TCP or UDP ports, filter the traffic by port.

     ![](./mediaWS/media/image11.png)

   - **Filter by Protocol:**  
     If the application uses a specific protocol (e.g., HTTP, HTTPS, FTP), focus on that protocol:

     ![](./mediaWS/media/image12.png)

8. **Write a C or C++ program to develop a packet capture and filtering application using raw sockets.**

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <unistd.h>
   #include <sys/socket.h>
   #include <netinet/in.h>
   #include <arpa/inet.h>
   #include <netinet/ip.h>
   #include <netinet/tcp.h>
   #include <errno.h>

   #define BUFFER_SIZE 65536

   void process_packet(unsigned char* buffer, int size) {
       struct iphdr* ip_header = (struct iphdr*) buffer;
       struct tcphdr* tcp_header;

       // Check if the protocol is TCP
       if (ip_header->protocol == IPPROTO_TCP) {
           tcp_header = (struct tcphdr*) (buffer + (ip_header->ihl * 4));

           struct sockaddr_in source, dest;
           memset(&source, 0, sizeof(source));
           source.sin_addr.s_addr = ip_header->saddr;
           memset(&dest, 0, sizeof(dest));
           dest.sin_addr.s_addr = ip_header->daddr;

           printf("TCP Packet - Source IP: %s, Source Port: %u, Destination IP: %s, Destination Port: %u\n",
                  inet_ntoa(source.sin_addr), ntohs(tcp_header->source),
                  inet_ntoa(dest.sin_addr), ntohs(tcp_header->dest));
       }
   }

   int main() {
       int sock_raw;
       struct sockaddr saddr;
       unsigned char* buffer = (unsigned char*) malloc(BUFFER_SIZE);
       int data_size;

       // Create a raw socket that shall sniff
       sock_raw = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));
       if (sock_raw < 0) {
           perror("Socket Error");
           return 1;
       }

       while (1) {
           socklen_t saddr_size = sizeof(saddr);
           // Receive a packet
           data_size = recvfrom(sock_raw, buffer, BUFFER_SIZE, 0, &saddr, &saddr_size);
           if (data_size < 0) {
               perror("Recvfrom error");
               return 1;
           }

           // Process the packet
           process_packet(buffer, data_size);
       }

       close(sock_raw);
       free(buffer);
       return 0;
   }
   ```
---

### Date: 02-07-2024 

## Networking Programs

### 1. Socket Programming – Using TCP

#### Server Code

**Explanation:** This server code creates a TCP socket, binds it to a specified address and port, and listens for incoming connections. Upon establishing a connection with a client, it receives messages from the client, prints them, and echoes them back.

```python
import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

server_address = ('localhost', 9999)
server_socket.bind(server_address) 

server_socket.listen(1)

print("Waiting for a connection...")
connection, client_address = server_socket.accept()

try:
    print("Connection from", client_address)
    while True:
        data = connection.recv(1024)
        if not data:
            break
        print("Received: ", data.decode())
        connection.sendall(data)
finally:
    connection.close()
```

**Output:**
```
Waiting for a connection...
Connection from ('127.0.0.1', 51234)
Received:  Hello, Server!
```

#### Client Code

**Explanation:** This client code creates a TCP socket and connects to the server. It prompts the user to enter a message, sends it to the server, and then waits to receive the echoed message.

```python
import socket

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

server_address = ('localhost', 9999)
client_socket.connect(server_address)

try:
    message = input("Enter a message to send to the server: ")
    client_socket.sendall(message.encode())

    data = client_socket.recv(1024)
    print("Received from server: ", data.decode())
    
finally:
    client_socket.close()
```

**Output:**
```
Enter a message to send to the server: Hello, Server!
Received from server:  Hello, Server!
```

### 2. Socket Programming – Using UDP

#### Server Code

**Explanation:** This UDP server code listens for incoming datagrams on a specified port. Upon receiving a message, it prints the message and the address of the sender, then echoes the message back to the client.

```python
import socket

# Server configuration
UDP_IP = "127.0.0.1"  # Localhost
UDP_PORT = 5005       # Port to listen on

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((UDP_IP, UDP_PORT))

print(f"UDP Server listening on {UDP_IP}:{UDP_PORT}...")

while True:
    # Wait for data from a client
    data, addr = sock.recvfrom(1024)  # Buffer size is 1024 bytes
    print(f"Received message: {data.decode()} from {addr}")

    # Echo the received message back to the client
    sock.sendto(data, addr)
```

**Output:**
```
UDP Server listening on 127.0.0.1:5005...
Received message: Hello, UDP Server! from ('127.0.0.1', 51235)
```

#### Client Code

**Explanation:** This UDP client code sends a predefined message to the server and waits for a response. After sending the message, it prints the reply from the server.

```python
import socket

# Server configuration
UDP_IP = "127.0.0.1"  # Server IP address
UDP_PORT = 5005       # Server Port

# Message to send
message = "Hello, UDP Server!".encode()

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Send message to the server
sock.sendto(message, (UDP_IP, UDP_PORT))

# Wait for the server's response
data, server = sock.recvfrom(1024)
print(f"Received reply from server: {data.decode()}")

# Close the socket
sock.close()
```

**Output:**
```
Received reply from server: Hello, UDP Server!
```

### 3. Broadcast Socket

#### Server Code

**Explanation:** This broadcast server code creates a UDP socket that listens for broadcast messages. Upon receiving a message, it prints the message along with the client's address.

```python
import socket

# Create a UDP socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Enable the option to allow broadcast messages
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

# Bind the socket to a broadcast address and port
server_address = ('', 9999)  # '' means listen on all available interfaces

server_socket.bind(server_address)

print("Broadcast server up and listening...")

while True:
    # Receive broadcast message
    data, client_address = server_socket.recvfrom(1024)
    print(f"Received broadcast from {client_address}: {data.decode()}")
```

**Output:**
```
Broadcast server up and listening...
Received broadcast from ('192.168.1.100', 51236): This is a broadcast message.
```

#### Client Code

**Explanation:** This broadcast client code sends a message to the broadcast address, allowing multiple clients to receive it. 

```python
import socket

# Create a UDP socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Enable the option to send broadcast messages
client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

# Broadcast address and port
broadcast_address = ('255.255.255.255', 9999)
message = "This is a broadcast message."

try:
    # Send the broadcast message
    client_socket.sendto(message.encode(), broadcast_address)
    print("Broadcast message sent.")
finally:
    # Close the socket
    client_socket.close()
```

**Output:**
```
Broadcast message sent.
```

### 4. Multicast Socket

#### Server Code

**Explanation:** This multicast server code listens for messages sent to a multicast group address. It joins the multicast group and waits to receive messages, printing the sender's address and the received data.

```python
import socket
import struct

# Step 1: Define the multicast group and server address (port)
multicast_group = '224.1.1.1'  # Multicast IP address
server_address = ('', 10000)    # Bind to any available network interface, port 10000

# Step 2: Create a UDP socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Step 3: Bind the socket to the server address and port
server_socket.bind(server_address)

# Step 4: Join the multicast group
group = socket.inet_aton(multicast_group)  # Convert the multicast IP address to binary format
mreq = struct.pack('4sL', group, socket.INADDR_ANY)  # Pack the binary IP address and network interface
server_socket.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)  # Join the multicast group

print("Waiting to receive (Multicast)...")

# Step 5: Wait to receive data (blocking call)
data, address = server_socket.recvfrom(1024)  # Receive up to 1024 bytes of data from any client

# Step 6: Print the received data and the address of the sender
print("Received from", address, "(Multicast):", data.decode())

# Step 7: Close the server socket
server_socket.close()
```

**Output:**
```
Waiting to receive (Multicast)...
Received from ('192.168.1.10', 51237) (Multicast): Hello, this is a multicast message.
```

#### Client Code

**Explanation:** This multicast client code sends a message to the multicast group, allowing all clients that have joined the group to receive the message.

```python
import socket
import struct

# Step 1: Define the multicast group and server port
multicast_group = ('224.1.1.1', 10000)  # Multicast IP and port

# Step 2: Create a UDP socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Step 3: Set the time-to-live (TTL) for multicast packets to allow them to pass through routers
ttl = struct.pack('b', 1)  # Set the TTL to 1 (local network only)
client_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)

# Step 4: Send the message to the multicast group
message = "Hello, this is a multicast message."
client_socket.sendto(message.encode(), multicast_group)

# Step 5: Close the client socket
client_socket.close()
```

**Output:**
```
# No output for the client; it simply sends the message.
```

### 5. Implement the Checksum

**Explanation:** This function calculates the checksum of a given byte sequence. It processes the data in 16-bit chunks, sums them, and returns the one's complement of the sum as the checksum.

```python
def calculate_checksum(data):
    if len(data) % 2 != 0:
        data += b'\0'
    
    sum_val = 0
    for i in range(0, len(data), 2):
        word = (data[i] << 8) + data[i + 1]
        sum_val += word

    while sum_val >> 16:
        sum_val = (sum_val & 0xFFFF) + (sum_val >> 16)

    checksum = ~sum_val & 0xFFFF
    return checksum

data = b'

Hello, world!'
checksum = calculate_checksum(data)
print("Checksum:", hex(checksum))
```

**Sample Output:**
```
Checksum: 0xe59e
```

### 6. Implementation and Simulation of Algorithms for Routing Protocols (Dijkstra's and Link State Routing)

**Explanation:** This code creates a graph representing a network using NetworkX, defines the edges with weights (costs), and uses Dijkstra's algorithm to find the shortest path from each router to all other routers.

```python
import networkx as nx

G = nx.Graph()

edges = [("A", "B", 5), ("A", "D", 8), ("B", "D", 7), ("B", "C", 2), ("C", "D", 6)]
G.add_weighted_edges_from(edges)

def link_state_routing(graph):
    for node in graph.nodes:
        lengths = nx.single_source_dijkstra_path_length(graph, node)
        paths = nx.single_source_dijkstra_path(graph, node)
        
        print(f"Router {node}'s shortest paths:")
        for dest, length in lengths.items():
            print(f"Path to node {dest}: {paths[dest]}, cost: {length}")
        print()

link_state_routing(G)
```

**Output:**
```
Router A's shortest paths:
Path to node A: ['A'], cost: 0
Path to node B: ['A', 'B'], cost: 5
Path to node C: ['A', 'B', 'C'], cost: 7
Path to node D: ['A', 'D'], cost: 8

Router B's shortest paths:
Path to node A: ['B', 'A'], cost: 5
Path to node B: ['B'], cost: 0
Path to node C: ['B', 'C'], cost: 2
Path to node D: ['B', 'D'], cost: 7

Router C's shortest paths:
Path to node A: ['C', 'B', 'A'], cost: 7
Path to node B: ['C', 'B'], cost: 2
Path to node C: ['C'], cost: 0
Path to node D: ['C', 'D'], cost: 6

Router D's shortest paths:
Path to node A: ['D', 'A'], cost: 8
Path to node B: ['D', 'B'], cost: 7
Path to node C: ['D', 'C'], cost: 6
Path to node D: ['D'], cost: 0
```

### 7. IP Spoofing

**Explanation:** This code uses the Scapy library to send a TCP packet with a spoofed source IP address. This technique can be used for various purposes, including testing and security assessments.

```python
#pip install scapy
from scapy.all import *

if __name__ == "__main__":
    target_ip = "192.168.1.10"  # Change to the target IP address
    spoofed_ip = "10.0.0.1"      # Change to the spoofed IP address

    send(IP(src=spoofed_ip, dst=target_ip) / TCP(sport=RandShort(), dport=80, flags='S'))
    print(f"Sent packet from {spoofed_ip} to {target_ip}")
```

**Output:**
```
Sent packet from 10.0.0.1 to 192.168.1.10
```
---
### Date:
### 1. SMTP Client using TCP

**Explanation:** This program demonstrates how to implement a simple SMTP client using the TCP protocol. It connects to an SMTP server, sends a HELO command, specifies the sender and recipient email addresses, sends the email body, and finally closes the connection.

**Program:**
```python
import socket

# SMTP server details
server = "mail.example.com"  # Replace with the actual SMTP server
port = 25
# Sender and recipient email addresses
from_email = "sender@example.com"
to_email = "recipient@example.com"
# Email message content
subject = "Hello from SMTP Client"
body = "This is a test email from the SMTP client."
# Format the email message
message = f"From: {from_email}\r\nTo: {to_email}\r\nSubject: {subject}\r\n\r\n{body}\r\n.\r\n"
# Create a TCP socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Connect to the SMTP server
client_socket.connect((server, port))
# Receive the server's welcome message
welcome_msg = client_socket.recv(1024)
print(welcome_msg.decode())
# Send the HELO command
client_socket.sendall(b"HELO example.com\r\n")
response = client_socket.recv(1024)
print(response.decode())
# Send the MAIL FROM command
client_socket.sendall(f"MAIL FROM: <{from_email}>\r\n".encode())
response = client_socket.recv(1024)
print(response.decode())
# Send the RCPT TO command
client_socket.sendall(f"RCPT TO: <{to_email}>\r\n".encode())
response = client_socket.recv(1024)
print(response.decode())
# Send the DATA command to start email data
client_socket.sendall(b"DATA\r\n")
response = client_socket.recv(1024)
print(response.decode())
# Send the email message
client_socket.sendall(message.encode())
# Send the QUIT command to close the connection
client_socket.sendall(b"QUIT\r\n")
response = client_socket.recv(1024)
print(response.decode())
```

**Output:**
```
220 mail.example.com ESMTP Postfix
250 mail.example.com
250 2.1.0 Ok
250 2.1.5 Ok
354 End data with <CR><LF>.<CR><LF>
250 2.0.0 Ok: queued as 12345
```

### 2. SMTP Client using UDP

**Explanation:** This program illustrates an attempt to implement the SMTP protocol over UDP. Note that SMTP typically uses TCP due to its need for reliable transmission, but this example demonstrates a simple UDP connection.

**Program:**
```python
import socket

# SMTP server details
server = "mail.example.com"  # Replace with the actual SMTP server
port = 25

# Sender and recipient email addresses
from_email = "sender@example.com"
to_email = "recipient@example.com"

# Email message content
subject = "Hello from SMTP Client"
body = "This is a test email from the SMTP client."

# Format the email message
message = f"From: {from_email}\r\nTo: {to_email}\r\nSubject: {subject}\r\n\r\n{body}\r\n.\r\n"

# Create a UDP socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Send HELO command
client_socket.sendto(b"HELO example.com", (server, port))
response, _ = client_socket.recvfrom(1024)
print(response.decode())

# Send the email message
client_socket.sendto(message.encode(), (server, port))

# Close the socket
client_socket.close()
```

**Output:**
```
220 mail.example.com ESMTP Postfix
```


### 3. FTP Client Program

**Explanation:** This program connects to an FTP server, logs in with credentials, lists the directory contents, and performs file download and upload operations.

**Program:**
```python
from ftplib import FTP

# FTP server details
ftp_host = "ftp.example.com"  # Replace with actual FTP server
ftp_user = "username"          # Replace with actual username
ftp_pass = "password"          # Replace with actual password

# Connect to FTP server
ftp = FTP(ftp_host)
ftp.login(ftp_user, ftp_pass)

# List directory
print("Directory listing:")
ftp.retrlines("LIST")

# Download file
with open("downloaded_file.txt", "wb") as file:
    ftp.retrbinary("RETR example.txt", file.write)

# Upload file
with open("upload_file.txt", "rb") as file:
    ftp.storbinary("STOR upload_file.txt", file)

# Close the connection
ftp.quit()
```

**Output:**
```
Directory listing:
drwxr-xr-x    2 user     group          4096 Oct 10 12:00 folder1
-rw-r--r--    1 user     group          1024 Oct 10 12:00 example.txt
```


### 4. FTP Packet Capture using Scapy

**Explanation:** This script captures FTP packets on the specified network interface, filtering for packets that use the FTP control port (21). It displays summaries of captured FTP packets.

**Program:**
```python
from scapy.all import *

def packet_callback(packet):
    if packet.haslayer(TCP) and packet[TCP].dport == 21:  # FTP control port
        print(f"FTP Packet: {packet.summary()}")

# Capture packets on interface 'eth0' (replace with your network interface)
sniff(iface="eth0", filter="tcp port 21", prn=packet_callback, count=10)
```

**Output:**
```
FTP Packet: TCP 192.168.1.10:55000 > 192.168.1.1:21 SYN
FTP Packet: TCP 192.168.1.1:21 > 192.168.1.10:55000 SYN, ACK
FTP Packet: TCP 192.168.1.10:55000 > 192.168.1.1:21 ACK
FTP Packet: TCP 192.168.1.10:55000 > 192.168.1.1:21 PSH, ACK
...
```


### 5. FTP Packet Analysis using Scapy

**Explanation:** This script analyzes captured FTP packets by decoding and printing out the FTP control messages sent to the FTP server.

**Program:**
```python
from scapy.all import *

# Define a callback to handle each captured packet
def analyze_packet(packet):
    if packet.haslayer(TCP) and packet[TCP].dport == 21:
        # Extract FTP control messages
        if packet.haslayer(Raw):
            print(f"FTP Command: {packet[Raw].load.decode('utf-8', errors='ignore')}")

# Capture packets (FTP traffic on port 21)
sniff(iface="eth0", filter="tcp port 21", prn=analyze_packet, count=50)
```

**Output:**
```
FTP Command: USER username
FTP Command: PASS password
FTP Command: LIST
```

### 6. FTP Traffic Simulation Program

**Explanation:** This program simulates packet transmission between two stations (A and B). Station A sends packets to Station B, which acknowledges receipt or requests missing packets to be resent.

**Program:**
```python
import random

def send_packets():
    packets_to_send = [1, 2, 3, 4, 5]  # Example packets to send
    received_packets = random.sample(packets_to_send, k=random.randint(3, 5))  # Simulate randomly received packets
    return received_packets

def station_A():
    all_packets = [1, 2, 3, 4, 5]
    while all_packets:
        received_packets = send_packets()
        if set(received_packets) == set(all_packets):
            print("All packets received successfully by Station B.")
            break
        else:
            missing_packets = list(set(all_packets) - set(received_packets))
            print(f"Missing packets: {missing_packets}")
            station_B_request_missing_packets(missing_packets)

def station_B_request_missing_packets(missing_packets):
    print("Requesting missing packets from Station A.")
    station_A_resend_packets(missing_packets)

def station_A_resend_packets(missing_packets):
    print(f"Resending missing packets: {missing_packets}")

# Run the simulation
station_A()
```

**Output:**
```
Missing packets: [2, 3]
Requesting missing packets from Station A.
Resending missing packets: [2, 3]
All packets received successfully by Station B.
```
---

